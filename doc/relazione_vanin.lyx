#LyX 2.2 created this file. For more info see http://www.lyx.org/
\lyxformat 508
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_title "IRC Server"
\pdf_author "Edoardo Vanin"
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder false
\pdf_colorlinks false
\pdf_backref false
\pdf_pdfusetitle true
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Server IRC
\end_layout

\begin_layout Author
Edoardo Vanin mat.
 1094068
\end_layout

\begin_layout Date
5 Luglio 2017
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
Introduzione
\end_layout

\begin_layout Standard
Il progetto consiste nella realizzazione di un server basato sul protocollo
 IRC.
 Il server deve sempre rimanere in ascolto ed accettare le connessioni da
 parte dei nuovi utenti.
 Per poter gestire al meglio le connessione di nuovi utenti, viene utilizzata
 la programmazione multithreading.
 Il programma è scritto in C, essendo un linguaggio di programmazione a
 basso livello permette una migliore elaborazione delle richieste grazie
 alla sua velocità di esecuzione
\end_layout

\begin_layout Subsection
Obbiettivi
\end_layout

\begin_layout Standard
L'obbiettivo del progetto è implementare un server in grado di far comunicare
 gli untenti all'interno delle stanza IRC per fare ciò c'è bisogno di implementa
re un numero minimo di comandi tra tutti i possibili definiti dal protocollo
 per la corretta comunicazione server-client
\end_layout

\begin_layout Standard
I seguenti comandi sono stati implementati:
\end_layout

\begin_layout Itemize
NICK comando per modificare il nomeutente
\end_layout

\begin_layout Itemize
USER comando per la registrazione dell'utente
\end_layout

\begin_layout Itemize
JOIN comando per entrare in una stanza
\end_layout

\begin_layout Itemize
MODE comando per visualizzare o modificare le caratteristiche di un canale
\end_layout

\begin_layout Itemize
WHO comando per avere informazioni su utenti/canali
\end_layout

\begin_layout Itemize
WHOIS comando per avere informazioni su utenti/canali
\end_layout

\begin_layout Itemize
PING comando per verificare la connessione
\end_layout

\begin_layout Itemize
PRIVMSG comando per inviare messaggi
\end_layout

\begin_layout Itemize
PART comando per abbandonare una stanza
\end_layout

\begin_layout Itemize
QUIT comando per disconnettersi dal server
\end_layout

\begin_layout Itemize
LIST comando per visualizzare tutte le stanza presenti nel server
\end_layout

\begin_layout Subsection
Motivazioni
\end_layout

\begin_layout Standard
Da sempre sono stato affascinato dalla comunicazione client-server così
 ho colto l'occasione al balzo per approfondire le mie conoscenze in questo
 ambito.
 Già dalle superiori sapevo che la comunicazione di rete tra programmi avviene
 mediante socket ma non ho mai avuto modo di poterla provare con mano.
 Un altro aspetto interessante è la programmazioe concorrente, anche di
 questa ne sapevo dell'esistenza ma non ho mai avuto modo di provarla con
 mano, qui la programmazione multithreading è assolutamtnente necessaria
 per gestire in modo indipendente i comandi provenienti dai vari utenti.
\end_layout

\begin_layout Section
Architettura e progettazione del software
\end_layout

\begin_layout Standard
Il progetto consiste in un programma che gestisce i comandi che gli arrivano
 dal più client.
\end_layout

\begin_layout Standard
Per farlo nel modo più veloce e corretto possibile si è seguito l'approccio
 
\emph on
divide et impera
\emph default
, il problema è stato diviso in due sottoproblemi, l'accettazione della
 connessione del client e la gestione dei comandi utente
\end_layout

\begin_layout Standard
L'accettazione è gestita all'interno del main mentre per la gestione dei
 comandi utente si è ricorso alla programmazione multithreading per poter
 gestire contemporaneamente comandi provenienti da utenti diversi
\end_layout

\begin_layout Subsection
Accettazione della connessione
\end_layout

\begin_layout Standard
Una volta avviato il programma il software rimane in ascolto di una connessione
 alla porta di default del protocollo IRC ovvero la porta 6667.
\end_layout

\begin_layout Standard
Una volta stabilita la connessione con il client, mediante protocollo TCP,
 il programma associa al nuovo utente un thread che gestirà i comandi ricevuti
 dal client.
\end_layout

\begin_layout Subsection
Gestione comandi utenti
\end_layout

\begin_layout Standard
La funzione che gestisce i comandi utente entra in un loop infinito per
 legge la stringa in arrivo nel socket associato all'utente mediante la
 funzione read, che data la sua natura bloccante non manda il programma
 in un loop infinito ma resta in attesa sino a quando l'utente non invia
 un 
\emph on
ritorno a capo.
 
\emph default
Con il ritorno capo la funzione ritorna e il ciclo while ricomincia per
 fare il parsing del comando appena inviato
\end_layout

\begin_layout Section
Sviluppo ed implementazione
\end_layout

\begin_layout Subsection
Stumenti per lo sviluppo
\end_layout

\begin_layout Standard
Per lo sviluppo di questo progetto sono stati utilizzati vari tool esterni,
 ed esempio:
\end_layout

\begin_layout Description
CMake CMake è un software libero multipiattaforma per l’automazione della
 compilazione il cui nome è un’abbreviazione di cross platform make.
\end_layout

\begin_layout Description
Git Git è un software di controllo versione distribuito utilizzabile da
 inter- faccia a riga di comando.
\end_layout

\begin_layout Description
Doxygen Doxygen è una applicazione per la generazione automatica della documenta
zione a partire dal codice sorgente di un generico software.
\end_layout

\begin_layout Description
Atom 
\begin_inset Quotes eld
\end_inset

A hackable text editor
\begin_inset Quotes erd
\end_inset

 Un semplice editor di testo creato dalla comunità di github appositamente
 per gli sviluppatori
\end_layout

\begin_layout Description
Lyx Lyx è un sistema per la preparazione di documenti tex-like
\end_layout

\begin_layout Subsection
Implementazione del codice
\end_layout

\begin_layout Standard
Di seguito verranno presentate e commentate le parti di codice più importanti
 essendo impossibile commentare tutti il codice date le sue notevoli dimensioni
\end_layout

\begin_layout Standard
Il server per funzionare dipende dalle librerie standard del C e da due
 librerie svilippate appositamente per gestire gli utenti e i canali.
\end_layout

\begin_layout Subsubsection
Libreria user
\end_layout

\begin_layout Standard
Questa libreria fornisce una struttura per descrivere gli utenti ed una
 lista doppiamente concatenata per collezionare gli utenti
\end_layout

\begin_layout Standard
Particolarmente interessanti risultano le funzioni di creazione utente ed
 inserimento dell'utente nella lista.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "numbers=left,basicstyle={\footnotesize\ttfamily}"
inline false
status open

\begin_layout Plain Layout

User* create_user(string name, string hostname,int id, int socket){
\end_layout

\begin_layout Plain Layout

  User* u =  malloc(sizeof(User));
\end_layout

\begin_layout Plain Layout

  u -> name = malloc(strlen(name));   
\end_layout

\begin_layout Plain Layout

  u -> hostname = malloc(strlen(hostname) + 1);
\end_layout

\begin_layout Plain Layout

  strcpy(u -> name, name);
\end_layout

\begin_layout Plain Layout

  strcpy(u -> hostname, hostname);
\end_layout

\begin_layout Plain Layout

  u -> id = id;
\end_layout

\begin_layout Plain Layout

  u -> socket = socket;
\end_layout

\begin_layout Plain Layout

  for (size_t i = 0; i < 15; i++) {
\end_layout

\begin_layout Plain Layout

    u -> channels[i] = NULL;
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  return u;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
La funzione alloca una zona di memoria per il nuovo utente e per le stringhe
 che conterranno nome utente e hostname, poi copia i parametri della funzione
 nei rispettivi campi dell'utente, infine inizializza a NULL il vettore
 che conterrà i nomi dei canali a cui l'utente è collegato.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "numbers=left,basicstyle={\footnotesize\ttfamily}"
inline false
status open

\begin_layout Plain Layout

int add_user(User_list** list, User* user){   
\end_layout

\begin_layout Plain Layout

  // Utente nullo o già presente
\end_layout

\begin_layout Plain Layout

  if(user == NULL || find_by_id(*list,user->id) != NULL){
\end_layout

\begin_layout Plain Layout

    return -1;
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  User_list* temp = malloc(sizeof(User_list)); // allocazione memoria
\end_layout

\begin_layout Plain Layout

  temp -> payload = user; // inserisco l'utene nel nodo di lista
\end_layout

\begin_layout Plain Layout

  //gestisco il caso critico: il primo inserimento
\end_layout

\begin_layout Plain Layout

  if(*list == NULL){
\end_layout

\begin_layout Plain Layout

    temp -> prev = NULL;
\end_layout

\begin_layout Plain Layout

    temp -> next = NULL;
\end_layout

\begin_layout Plain Layout

  } else {     //inserimento in testa
\end_layout

\begin_layout Plain Layout

    temp -> prev = NULL;
\end_layout

\begin_layout Plain Layout

    temp -> next = *list;
\end_layout

\begin_layout Plain Layout

    (*list) -> prev = temp;
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  *list = temp; // riassegnazione della testa della lista
\end_layout

\begin_layout Plain Layout

  return 1; // ritorno di successo
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
La funzione add_user gestisce l'inserimento nella lista di utenti, come
 parametri accetta l'indirizzo del puntatore alla struttura lista in cui
 inserire il nuovo utente
\end_layout

\begin_layout Standard
Come prima cosa controlla che l'utente sia un utente valido oppure non sia
 già presente nella lista, in questo caso non modifica la lista (non è permesso
 l'inserimento multiplo di utenti) e ritorna 
\emph on

\begin_inset Quotes eld
\end_inset

-1
\begin_inset Quotes erd
\end_inset


\emph default
 come valore, ad indicare che l'operazione di inserimento non è andata a
 buon fine.
\end_layout

\begin_layout Standard
Poi si ditiunguono due casi, il caso critico ovvero il primo inserimento
 e il caso in cui almeno un utente è presente nella lista.
\end_layout

\begin_layout Standard
Il primo inserimento è un caso critico in quanto l'operazione 
\begin_inset listings
lstparams "basicstyle={\footnotesize\ttfamily}"
inline false
status open

\begin_layout Plain Layout

(*list) -> prev = temp
\end_layout

\end_inset

 è vietata perché si cerca di accedere ad un campo di un puntatore nullo.
\end_layout

\begin_layout Standard
Infine riposiziona il puntatore passato come parametro alla testa della
 lista.
\end_layout

\begin_layout Subsubsection
Libreria channel
\end_layout

\begin_layout Standard
Questa libria fornisce una struttura per descrivere i canali ed una lista
 doppiamente concatenata collezionare i canali.
\end_layout

\begin_layout Standard
La struttura le funzioni che operano sulla struttura Channel_list sono una
 copia opportunamente modificata delle funzioni che operano sulla lista
 User_list, infatti entrambe le liste hanno una struttura di lista doppiamente
 concatenata ma accettano come oggetto da collezionare due tipi di dato
 diversi.
\end_layout

\begin_layout Standard
Per completezza verranno trattati la funzione di rimozione di un canale
 dalla lista, che a parte modifiche sul tipo di dato di ritorno è uguale
 alla funzione remove_user della libreria user_lib
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "numbers=left,basicstyle={\footnotesize\ttfamily}"
inline false
status open

\begin_layout Plain Layout

Channel* remove_channel(Channel_list** list, string name){
\end_layout

\begin_layout Plain Layout

  if(*list == NULL) return NULL;
\end_layout

\begin_layout Plain Layout

  Channel_list* temp = *list;
\end_layout

\begin_layout Plain Layout

  //scorro la lista per portarmi al canale scelto
\end_layout

\begin_layout Plain Layout

  while (strcmp(temp -> payload -> name, name) != 0) {
\end_layout

\begin_layout Plain Layout

    if(temp -> next == NULL) {
\end_layout

\begin_layout Plain Layout

      return NULL;
\end_layout

\begin_layout Plain Layout

    } else {
\end_layout

\begin_layout Plain Layout

      temp = temp -> next;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  if(temp -> next == NULL && temp -> prev == NULL){ //c'è un solo nodo
\end_layout

\begin_layout Plain Layout

    (*list) = NULL;
\end_layout

\begin_layout Plain Layout

  } else if(temp -> prev == NULL){ //caso in cui il nodo da rimuovere è
 il primo
\end_layout

\begin_layout Plain Layout

    temp -> next -> prev = NULL;
\end_layout

\begin_layout Plain Layout

    *list = (*list) -> next;
\end_layout

\begin_layout Plain Layout

  } else if(temp -> next == NULL) { //devo rimuovere l'ultimo
\end_layout

\begin_layout Plain Layout

    temp -> prev -> next = NULL;
\end_layout

\begin_layout Plain Layout

  } else {
\end_layout

\begin_layout Plain Layout

    temp -> prev -> next = temp -> next;
\end_layout

\begin_layout Plain Layout

    temp -> next -> prev = temp -> prev;
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  Channel* chan = temp -> payload; //salvo il canale
\end_layout

\begin_layout Plain Layout

  free(temp); // libero la cella di memoria puntata
\end_layout

\begin_layout Plain Layout

  return chan; //ritoro il canale
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Il primo controllo che fa la funzione riguarda la correttezza del puntatore
 alla lista, se esso è NULL non ha senso cercare un nodo da rimuovere che
 non c'è e anzi se si cercassero di fare operazioni su tale puntatore si
 solleverebbe un errore di 
\emph on

\begin_inset Quotes eld
\end_inset

core dump
\begin_inset Quotes erd
\end_inset

 
\emph default
che farebbe terminare il programma.
\end_layout

\begin_layout Standard
Se il primo controllo va a buon fine, con un puntatore temporaneo si scorre
 la lista fino a puntare il nodo da eliminare.
\end_layout

\begin_layout Standard
Per rimuoverlo si possono identificare quattro casi, tre critici con gestioni
 leggermente diverse dal caso generale, essi sono la rimozione del nodo
 centrale, la rimozione del nodo in coda e la presenza di un sono nodo.
 Sono casi critici perché nel caso rimozione del nodo di testa e rimozione
 del nodo in coda vengono svolte operazioni che causano un errore di 
\emph on

\begin_inset Quotes eld
\end_inset

core dump
\begin_inset Quotes erd
\end_inset


\emph default
 ed esse sono rispettivamente
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "numbers=left,basicstyle={\footnotesize\ttfamily}"
inline false
status open

\begin_layout Plain Layout

temp -> prev -> next = temp -> next;
\end_layout

\begin_layout Plain Layout

temp -> next -> prev = temp -> prev;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Le operazioni tentano di eseguire un accesso ad un parametro di una struttura
 che punta a NULL.
\end_layout

\begin_layout Standard
Infine nel caso di un solo nodo sono violate contemporaneamente perche un
 sono nodo ha i puntatori precedente e successivo a NULL.
\end_layout

\begin_layout Standard
Una volta rimosso il nodo di lista che contiene il canle cercato, colleziono
 con un nuovo puntatore il canale cercato, libero la zona di memoria occupata
 dal nodo della lista ed infine ritorno il canale cercato, sarà il chiamante
 a decidere cosa farne.
\end_layout

\begin_layout Standard
Una differenza tra struttua Channel e la struttura User è il fatto che all'inter
no della struttura Channel esiste una lista che colleziona gli utenti presenti
 nel canale mentre nella struttura User è presente un vettore di stringhe
 contente i nomi di canali a cui l'utente è accreditato.
 Ho adoperato questa scelata perché è conveniente ai fini della velocità
 di esecuzione del programma in quanto l'invio di messaggi nel canale è
 un'operazione svolta con maggior frequenza, mentre l'abbandono del server,
 che è l'unico motivo per cui esiste questo vettore, è molto più raro e
 può avere tempi di latenza maggiori rispetto all'invio di messaggi, operazione
 che deve essere svolta in modo più veloce.
\end_layout

\begin_layout Subsubsection
Libreria utils
\end_layout

\begin_layout Standard
Come suggerisce il nome contiente funzioni di utilità, utilità a gestire
 i casi del comando WHO infatti le tre funzioni implementate corrispondono
 ai vari casi in cui viene chiamato il comando WHO prendiamo in esame il
 caso in cui viene chiamato il comando WHO e come parametro viene inserito
 il nome di un canale.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "numbers=left,basicstyle={\footnotesize\ttfamily}"
inline false
status open

\begin_layout Plain Layout

void send_channel_info(User* u, Channel* c) {
\end_layout

\begin_layout Plain Layout

  User_list* list = c -> users;
\end_layout

\begin_layout Plain Layout

  User* target;
\end_layout

\begin_layout Plain Layout

  char* send_line = malloc(MAXLINE + 1);
\end_layout

\begin_layout Plain Layout

  while (list != NULL) {
\end_layout

\begin_layout Plain Layout

    target = list -> payload;
\end_layout

\begin_layout Plain Layout

    send_user_info(u, target, c -> name);
\end_layout

\begin_layout Plain Layout

    list = list -> next;
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  strcpy(send_line, ":");
\end_layout

\begin_layout Plain Layout

  strcat(send_line, SERVER_NAME);
\end_layout

\begin_layout Plain Layout

  strcat(send_line, " ");
\end_layout

\begin_layout Plain Layout

  strcat(send_line, RPL_ENDOFWHO);
\end_layout

\begin_layout Plain Layout

  strcat(send_line, " ");
\end_layout

\begin_layout Plain Layout

  strcat(send_line, u -> name);
\end_layout

\begin_layout Plain Layout

  strcat(send_line, ENDOFWHO);
\end_layout

\begin_layout Plain Layout

  write(u -> socket, send_line, strlen(send_line));
\end_layout

\begin_layout Plain Layout

  free(send_line);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Le operazioni iniziali creano un puntatore alla lista utenti del canale
 per raccogliere ed inviare all'utente u che ha chiamato il comando WHO
 le informazioni di tutti gli utenti presenti nel canale.
 Il ciclo while serve appunto per iterare la lista e inviare le informazioni
 di tutti gli utenti presenti nel canale.
\end_layout

\begin_layout Standard
Infine viene costruita la striga per indicare la fine della lista in risposta
 al comando WHO, viene inviata e liberata la zona di memoria occupata.
\end_layout

\begin_layout Subsubsection
Libreria user_thread
\end_layout

\begin_layout Standard
La libreria principe che contiene la funzione da associare al thread dell'utente
, essa gestisce i comandi inviati dall'utente.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "numbers=left,basicstyle={\footnotesize\ttfamily}"
inline false
status open

\begin_layout Plain Layout

void user_thread(User* u){
\end_layout

\begin_layout Plain Layout

  char recvline[MAXLINE + 1];
\end_layout

\begin_layout Plain Layout

  char* line = malloc((MAXLINE + 1) * sizeof(char));
\end_layout

\begin_layout Plain Layout

  char* send_line = malloc((MAXLINE + 1) * sizeof(char));
\end_layout

\begin_layout Plain Layout

  char* command;
\end_layout

\begin_layout Plain Layout

  ssize_t n;
\end_layout

\begin_layout Plain Layout

  pthread_mutex_lock(&(u -> socket_mutex));
\end_layout

\begin_layout Plain Layout

  n = read(u -> socket, recvline, MAXLINE);
\end_layout

\begin_layout Plain Layout

  pthread_mutex_unlock(&(u -> socket_mutex));
\end_layout

\begin_layout Plain Layout

  while(n > 0){
\end_layout

\begin_layout Plain Layout

    recvline[n] = 0;
\end_layout

\begin_layout Plain Layout

    line = strcpy(line, recvline);
\end_layout

\begin_layout Plain Layout

    command = strtok(line, " 
\backslash
t
\backslash
r
\backslash
n/");
\end_layout

\begin_layout Plain Layout

    while (command != NULL) {
\end_layout

\begin_layout Plain Layout

      printf("L'utente: %i ha inviato il comando: %s
\backslash
n",u -> id, command);
\end_layout

\begin_layout Plain Layout

      /*Qui parte lo switch di comparazaione con i comandi conosciuti*/
\end_layout

\begin_layout Plain Layout

	  if(strcmp(command, NICK) == 0){
\end_layout

\begin_layout Plain Layout

		...
\end_layout

\begin_layout Plain Layout

	  }
\end_layout

\begin_layout Plain Layout

	  ...
\end_layout

\begin_layout Plain Layout

      command = strtok(NULL, " 
\backslash
t
\backslash
r
\backslash
n/");
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    pthread_mutex_lock(&u->socket_mutex);
\end_layout

\begin_layout Plain Layout

    n = read(u->socket, recvline, MAXLINE);
\end_layout

\begin_layout Plain Layout

    pthread_mutex_unlock(&u->socket_mutex);
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Nella parte iniziale creo tutte le variabili per poter fare un parsing della
 stringa line, ovvero quella che conterrà il comando con i suoi parametri.
\end_layout

\begin_layout Standard
Per poter leggere la stringa di dati uso la funzione read sul socket dell'utente
 ma, essendo il socket una risorsa condivisa, ed accessibile conteporanemente
 da più thread, ho usato il sistema di semafori messo a disposizione dalla
 libreria pthread per gestire la lettura e scritura concorrente da parte
 di più utenti, in particolare le funzioni pthread_mutex_lock e pthread_mutex_un
lock bloccano o liberano la risorsa condivisa o meglio il semaforo associato
 alla risorsa.
\end_layout

\begin_layout Standard
Segue il ciclo while principale per gestire la successione di stringhe inviate
 dall'utente, ed annidato il secondo ciclo while per parsare la stringa
 con la funzione strtok e selezionare il comando ricchiesto dall'utente
 mediante una serie di decisioni if - else if.
\end_layout

\begin_layout Subsubsection
File main.c
\end_layout

\begin_layout Standard
Nel main file c'è l'unica funzione main, la principale, il cui unico compito
 è gestire le connessioni in ingresso dai vari utenti
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "numbers=left,basicstyle={\footnotesize\ttfamily}"
inline false
status open

\begin_layout Plain Layout

while(1){
\end_layout

\begin_layout Plain Layout

    //accept non è all'interno dell'if di decisione perché è una funzione
 bloccante
\end_layout

\begin_layout Plain Layout

    if ((user_socket = accept(server_socket,
\end_layout

\begin_layout Plain Layout

                            (struct sockaddr *) &client_address,
\end_layout

\begin_layout Plain Layout

                            &client_address_size)) == -1 ) {
\end_layout

\begin_layout Plain Layout

      fprintf(stderr, "[Errore chiamando accept: %s]
\backslash
n", strerror(errno));
\end_layout

\begin_layout Plain Layout

      exit(5);
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    // aggiunge l'utente alla lista se permesso
\end_layout

\begin_layout Plain Layout

    if(count < MAXUSER){
\end_layout

\begin_layout Plain Layout

      strcpy(username, "user"); //pulisco la stringa dal nome precendente
\end_layout

\begin_layout Plain Layout

      sprintf(temp,"%d", u_id);
\end_layout

\begin_layout Plain Layout

      strcat(username, temp);
\end_layout

\begin_layout Plain Layout

      new_user = create_user( username,
\end_layout

\begin_layout Plain Layout

                              inet_ntoa(client_address.sin_addr),
\end_layout

\begin_layout Plain Layout

                              u_id,
\end_layout

\begin_layout Plain Layout

                              user_socket);
\end_layout

\begin_layout Plain Layout

      u_id = u_id + 1; //incrementa il contatore degli id
\end_layout

\begin_layout Plain Layout

      pthread_mutex_lock(&main_user_list_mutex);
\end_layout

\begin_layout Plain Layout

      add_user(&main_user_list,new_user);
\end_layout

\begin_layout Plain Layout

      count = count + 1; //va a braccetto con la lista, deve andare qui
\end_layout

\begin_layout Plain Layout

      pthread_mutex_unlock(&main_user_list_mutex);
\end_layout

\begin_layout Plain Layout

      pthread_create(&(new_user -> thread), NULL, (void* (*)(void*))user_thread,
 new_user);
\end_layout

\begin_layout Plain Layout

    } else { //troppi utenti glielo dico
\end_layout

\begin_layout Plain Layout

      close(user_socket); // così rifiuto la connessione, chiudendo il socket
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Prima di questo loop infinito, ovviamente ci sono tutte le chiamate a funzione
 per inizializzare la porta e le strutture dati necessarie per gestire il
 cliente.
\end_layout

\begin_layout Standard
Interessante è il ruolo giocato dalla funzione accept, una funzione bloccante
 che ritorna solo se c'è un elemento nella coda di attesa delle connessioni,
 se la code fosse vuota, la funzione accept aspetta finchè non c'è una connessio
ne da gestire.
\end_layout

\begin_layout Standard
La funzione estrae la prima connessione dalla coda del listen socket, ovvero
 il socket associato al servizio creato con le funzioni precedenti, crea
 un nuovo socket per l'utente e ritorna un file descriptor per tale socket,
 il nuovo socket creato non è nello stato di listen.
\end_layout

\begin_layout Standard
Se l'operazione di accettazione è andata a buon fine e non ci sono troppi
 utenti nel sistema, inserisco il nuovo utente nella lista principale degli
 utenti, aumento il contatore associato alla lista e associo all'utente
 il thread che dovrà gestire i comandi.
\end_layout

\begin_layout Standard
Se invece l'operazione di accettazione è andata a buonfine ma ci sono troppi
 utenti, semplicemente non creo l'utente e chiudo il socket appena creato.
\end_layout

\begin_layout Standard
Infine se l'accettazione non è andata a buon fine termino il programma,
 evento abbastanza critico ma necessario perchè se la funzione accept fallisce
 è sintomo di problemi di rete.
\end_layout

\begin_layout Section
Valutazione e collaudo
\end_layout

\begin_layout Standard
Il programma è stato collaudato man mano con esempi inseriti manualmente
 ed ogni libreria presente nel progetto è stata provata in diversi scenari
 durante lo sviluppo cercando di eliminare i bug che si pressentavano via
 via che il progetto cresceva, importanti sono state le modifiche alla struttra
 del progetto per la gestione dei comandi WHO e PART.
 Per risolvere in modo efficente il problema di raggiungere tutti i canali
 a cui un utente è collegato ho dovuto aggiungere il campo 
\emph on
channels
\emph default
 all'interno della struttura 
\emph on
User
\emph default
 con conseguente modifica dei metodi per la creazione e rimozione dell'utente.
\end_layout

\begin_layout Standard
Per testare tutti i casi critici delle liste utente e canale mi sono avvalso
 del framework Check creando due test case ed è grazie a questi test che
 sono riuscito a identificare e risolvere i casi critici che non avevo considera
to.
\end_layout

\begin_layout Standard
Un altro bug che mi ha fatto penare è stata la dimenticanza del carattere
 
\emph on

\begin_inset Quotes eld
\end_inset


\backslash
n
\begin_inset Quotes erd
\end_inset


\emph default
 come terminazione delle stringhe di invio all'utente solo a posteriori
 ho capito dell'importanza di tale terminazione e, dopo una sera intera
 alla ricerca dell'errore, sono riuscito a far funzionare il comando PRIVMSG,
 comando che per primo presentò tale bug.
\end_layout

\begin_layout Standard
Altri possibili bug sono dovuti all'utilizzo improprio dei parametri dei
 vari comandi, ad esempio se si cerca di chiamare il comando PING e passando
 come paramtro il nome di un utente, c'è una possibilità significativamente
 alta che il programma vada in crash.
 Nonostante tale configurazione sia lecita da specifica di protocollo.
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
Conclusioni e lavoro futuro
\end_layout

\begin_layout Standard
Nonostante le molteplici difficoltà trovate, specialmente nella gestione
 dei comandi utenti, mi sento soddisfatto del lavoro svolto.
\end_layout

\begin_layout Standard
Ho acquisito molte più competenze specialmente nella gestione di un progetto
 mediante git.
 Sicuramente continuerò ad approfondire la programmazione di rete anche
 in vista della tesi e della laurea magistrale.
 
\end_layout

\begin_layout Standard
Possibili sviluppi del software potrebbero includere:
\end_layout

\begin_layout Itemize
Ampliare lo spettro dei comandi gestibili dal server 
\end_layout

\begin_layout Itemize
Possibilià dello scambio di file
\end_layout

\begin_layout Itemize
Estensione del comando PRIVMSG al caso utente-utente
\end_layout

\begin_layout Itemize
Una migliore formattazione delle risposte al client
\end_layout

\begin_layout Itemize
Implementazione di tutti i casi 
\end_layout

\end_body
\end_document
